(* The Tau fan *)

From intuitionism Require Import lib set seq spr fan func classic bcp.

Section TauFan.

(* The Tau fan contains all monotone sequences with a given bounds. *)
Variable lower : nat.
Variable range : nat.

Fixpoint τσ (s : fseq) :=
  match s with
  | [] => true
  | n :: s' =>
    match s' with
    | [] => true
    | m :: s'' => (m <=? n) && τσ s'
    end && (lower <=? n) && (n <=? lower + range)
  end.

Lemma τσ_nil : τσ [] = true.
Proof. auto. Qed.

Lemma τσ_cons s : τσ s = true <-> exists n, τσ (n :: s) = true.
Proof.
split; intros. destruct s.
- exists lower; simpl; bool_lia.
- exists n; simpl in *; destruct s; repeat bool_to_Prop; try lia; auto.
- destruct H as [n H]; simpl in H; destruct s; auto; repeat bool_to_Prop; auto.
Qed.

Lemma τσ_fan s :
  τσ s = true -> exists n, forall m, τσ (m :: s) = true -> m <= n.
Proof.
intros; exists (lower + range); intros.
simpl in H0; destruct s; bool_lia.
Qed.

Definition τ := Fan (Spr τσ τσ_nil τσ_cons) τσ_fan.

(* Alternative membership criteria *)
Definition τP α := forall n, lower <= α n <= lower + range /\ α n <= α (S n).

Lemma intro_τP α n :
  τP α -> τσ ⟨α;n⟩ = true.
Proof.
intros H; induction n; simpl; auto.
destruct ⟨α;n⟩ eqn:E; repeat bool_to_Prop; auto; try apply H.
destruct n; simpl in *. discriminate. inversion_clear E; apply H.
Qed.

Lemma member_τP α :
  α isin τ <-> τP α.
Proof.
split.
- intros H n; eapply unfold_inspr with (m:=S (S n)) in H; simpl in H.
  destruct ⟨α;n⟩ eqn:E; bool_lia.
- intros H m. apply intro_τP; auto.
Qed.

(* τ is monotone. *)
Lemma τ_mono α :
  α isin τ -> forall i j, i <= j -> α i <= α j.
Proof.
intros. apply le_exists_sub in H0 as [d [Hd _]]. rewrite Hd; clear Hd.
revert i; induction d; intros; simpl; try lia.
replace (S (d + i)) with (d + S i) by lia.
transitivity (α (S i)); auto. apply member_τP; auto.
Qed.

(* Restrict range. *)
Lemma τ_mono_ext α n i j :
  α isin τ -> i <= j -> n <= α i -> n <= α j <= lower + range.
Proof.
intros H1 H2 H3; split. transitivity (α i); auto.
apply τ_mono; auto. apply member_τP; auto.
Qed.

End TauFan.

Definition τ1 := τ 0 0.
Definition τ2 := τ 0 1.
Definition τ3 := τ 0 2.
Definition τ4 := τ 0 3.

(* Some results about τ2. *)
Module Tau2.

(* Any element of τ2 is 0 or 1. *)
Lemma τ2_cases α n :
  α isin τ2 -> α n = 0 \/ α n = 1.
Proof.
intros; apply member_τP in H; destruct (α n) eqn:E; auto.
right; rewrite <-E. assert(D: α n <= 1). apply H. lia.
Qed.

(* Any function τ2 -> Nat has a finite image. *)
Theorem τ2_to_Nat_fin_image (f : seq -> nat) :
  exists image, forall α, α isin τ2 -> In (f α) image.
Proof.
(* Number of leading zeros after which f outputs a result. *)
destruct (BCP _ (f_computable f) (0^ω)) as [m [n Hbcp]].
(* Full image is generated by the sequences up to 0^m. *)
exists (map (fun k => f (pre k (0^ω) (1^ω))) (0..m)).
intros α Hα. pose(k := compare m α (0^ω)).
assert(kleqm: k <= m). unfold k; apply compare_leq.
assert(Hk: eqn k α (0^ω)). apply eqn_compare.
apply in_map_range with (k0:=k); auto. destruct (eq_dec k m).
- rewrite e. rewrite Hbcp. symmetry; apply Hbcp.
  apply eqn_pre_n. rewrite <-e. now apply eqn_sym.
- apply f_equal. extensionality i. unfold pre, replace, fill.
  destruct (i <? k) eqn:E; bool_to_Prop; unfold cseq.
  apply Hk; lia. destruct (τ2_cases α i); auto.
  assert(Hlt: k < m). lia. assert(Heqk: k = compare m α (0^ω)). auto.
  apply compare_lt in Hlt. rewrite <-Heqk in Hlt.
  exfalso. apply Hlt; unfold cseq.
  apply (τ_mono _ _ α) in E; auto. lia.
Qed.

(*
Classical surjection is different from intuitionistic surjection.
See classic.v for a proof that f is surjective under LPO.
*)
Definition f n :=
  match n with
  | 0 => 0^ω
  | S m => pre m (0^ω) (1^ω)
  end.

Lemma f_image n :
  f n isin τ2.
Proof.
apply intro_inspr; intros; apply intro_τP. unfold f; destruct n.
- intros n; unfold cseq; lia.
- intros i. split. split; apply pre_prop; intros; unfold cseq; lia.
  unfold pre, replace, fill, cseq.
  destruct (i <? n) eqn:E1; destruct (S i <? n) eqn:E2; bool_lia.
Qed.

(* f is injective. *)
Theorem f_inj :
  injective Nat τ2 f.
Proof.
intros n m _ _; simpl; unfold dec_apart; intros H.
assert(C: n < m \/ m < n). lia. destruct C, n, m; try lia; simpl.
- exists m. rewrite <-(add_0_r m) at 3; rewrite pre_r.
  unfold cseq; lia.
- exists n. apply le_exists_sub in H0 as [k [Hk _]].
  replace m with (n + S k) by lia. rewrite pre_l.
  rewrite <-(add_0_r n) at 2; rewrite pre_r. unfold cseq; lia.
- exists n. rewrite <-(add_0_r n) at 2; rewrite pre_r.
  unfold cseq; lia.
- exists m. apply le_exists_sub in H0 as [k [Hk _]].
  replace n with (m + S k) by lia. rewrite pre_l.
  rewrite <-(add_0_r m) at 3; rewrite pre_r. unfold cseq; lia.
Qed.

(* f is not surjective. *)
Theorem f_not_surj :
  ~surjective Nat τ2 f.
Proof.
assert(P0: 0^ω isin τ2). apply member_τP; intros n; unfold cseq; lia.
intros H; destruct (BCPext τ2 _ H (0^ω) P0) as [m [n Q]].
assert(P1: f (S (m + n)) isin τ2). apply f_image. apply Q in P1 as [_ P1].
revert P1; destruct n; simpl; intros P1.
- apply equal_f with (x:=m) in P1; revert P1.
  rewrite add_0_r; rewrite pre_r0.
  unfold cseq; intros; lia.
- apply equal_f with (x:=n) in P1; revert P1. rewrite pre_r0.
  replace (m + S n) with (n + S m) by lia. rewrite pre_l.
  unfold cseq; intros; lia.
- intros i Hi; unfold f. unfold pre, replace, fill.
  replace (i <? m + n) with true by bool_lia. lia.
Qed.

(* f is surjective under LPO. *)
Theorem lpo_f_surj :
  LPO -> surjective Nat τ2 Tau2.f.
Proof.
intros LPO; intros β Hβ; destruct (LPO β).
- pose(n := epsilon_smallest _ (neq0_dec β) H); destruct n as [n [Hn1 Hn2]].
  exists (S n); split. apply I. simpl; extensionality i.
  unfold pre, replace, fill, cseq.
  destruct (i <? n) eqn:E; bool_to_Prop. apply Hn2 in E; lia.
  eapply τ_mono_ext with (n:=1)(j:=i) in Hβ. lia. apply E. lia.
- exists 0; split. apply I. simpl.
  extensionality n; auto.
Qed.

End Tau2.
